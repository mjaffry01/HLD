<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Caching - Lecture Notes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            padding: 0;
            background-color: #f4f4f4;
        }
        header, footer {
            text-align: center;
            padding: 10px 0;
            background-color: #333;
            color: #fff;
            margin-bottom: 20px;
        }
        main {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        button {
            padding: 10px 20px;
            margin: 10px 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #controls {
            text-align: center;
            margin-bottom: 20px;
        }
        #readButton { background-color: #28a745; color: #fff; }
        #pauseButton { background-color: #ffc107; color: #fff; }
        #stopButton { background-color: #dc3545; color: #fff; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
    </style>
</head>
<body>

    <header>
        <h1>Introduction to Caching</h1>
    </header>

    <main>
        <div id="controls">
            <button id="readButton">Read</button>
            <button id="pauseButton">Pause</button>
            <button id="stopButton">Stop</button>
        </div>

        <section>
            <h2>After Securing a Domain: The Next Steps</h2>
            <p>Once you've registered a domain name, the journey to making your website accessible to the public begins. The primary goal is to ensure that when users enter your domain into their browsers, they can retrieve the desired resources seamlessly. This process involves resolving the domain name to an IP address, which is crucial for locating the server that hosts your website.</p>
        </section>

        <hr>

        <section>
            <h2>How Browsers Access Internet Resources</h2>
            <p>When a user types a URL like <code>google.com</code> into a browser, a sequence of events is triggered:</p>
            <ol>
                <li><strong>DNS Lookup</strong>: The browser initiates a query to the Domain Name System (DNS) to find the IP address associated with the domain name.</li>
                <li><strong>IP Address Retrieval</strong>: The DNS server responds with the corresponding IP address.</li>
                <li><strong>Resource Access</strong>: Using this IP address, the browser sends a request to the server to retrieve the website's resources.</li>
            </ol>
            <p>This process is essential for translating human-readable domain names into machine-understandable IP addresses, enabling communication over the internet.</p>
        </section>

        <hr>

        <section>
            <h2>The Role of IP Addresses and Caching</h2>
            <p>Visiting a modern website often requires the browser to send multiple requests—sometimes dozens—to load all necessary resources like HTML files, images, CSS stylesheets, and JavaScript files. Repeatedly fetching the IP address from DNS for each request can introduce significant delays.</p>
            <p>To optimize this process, browsers implement caching mechanisms:</p>
            <ul>
                <li><strong>IP Address Caching</strong>: Browsers store the IP address of a domain locally after the first DNS lookup. Subsequent requests can bypass the DNS query and directly use the cached IP address, reducing latency and improving load times. Since IP addresses typically remain static for a period, this cache is both practical and efficient.</li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Understanding Latency</h2>
            <p>Latency refers to the time delay between a request and the initiation of a response. It's a critical factor in system performance, especially in networking and data retrieval. The following comparisons illustrate how different operations impact latency:</p>
            <ul>
                <li><strong>Cache References</strong>:
                    <ul>
                        <li><strong>L1 Cache</strong>: ~0.5 nanoseconds (ns)</li>
                        <li><strong>L2 Cache</strong>: ~7 ns (14 times slower than L1)</li>
                    </ul>
                </li>
                <li><strong>Memory and Storage</strong>:
                    <ul>
                        <li><strong>Main Memory (RAM)</strong>: ~100 ns (20 times slower than L2)</li>
                        <li><strong>Solid-State Drive (SSD) Access</strong>: ~150,000 ns (150 microseconds)</li>
                        <li><strong>Disk Seek (Hard Drive)</strong>: ~10,000,000 ns (10 milliseconds)</li>
                    </ul>
                </li>
                <li><strong>Network Operations</strong>:
                    <ul>
                        <li><strong>Network Round Trip (e.g., over the internet)</strong>: ~150,000,000 ns (150 milliseconds)</li>
                    </ul>
                </li>
            </ul>
            <p>These figures highlight the importance of caching; accessing data from a cache is exponentially faster than retrieving it from main memory, disk storage, or over a network.</p>
        </section>

        <hr>

        <section>
            <h2>Practical Examples of Caching</h2>

            <h3>1. Facebook Newsfeed</h3>
            <ul>
                <li><strong>Challenge</strong>: Delivering personalized newsfeeds to millions of users in real-time.</li>
                <li><strong>Solution</strong>: Facebook caches users' newsfeeds in RAM, allowing quick access and reducing the need for repetitive database queries.</li>
                <li><strong>Benefit</strong>: Ensures a responsive user experience by minimizing latency and server load.</li>
            </ul>

            <h3>2. Netflix Streaming</h3>
            <ul>
                <li><strong>Challenge</strong>: Providing high-quality video streaming to a global audience.</li>
                <li><strong>Solution</strong>: Netflix uses Content Delivery Networks (CDNs) to cache video content on servers geographically closer to users.</li>
                <li><strong>Benefit</strong>: Reduces buffering times and improves streaming quality by minimizing the distance data must travel.</li>
            </ul>

            <h3>3. Twitter High-Traffic Posts</h3>
            <ul>
                <li><strong>Challenge</strong>: Handling massive traffic spikes when popular users post new content.</li>
                <li><strong>Solution</strong>: Twitter caches tweets from high-profile users to efficiently serve a large number of requests.</li>
                <li><strong>Benefit</strong>: Prevents server overload and maintains fast content delivery during peak times.</li>
            </ul>

            <h3>4. Content Delivery Networks (CDNs)</h3>
            <ul>
                <li><strong>Challenge</strong>: Delivering static content (images, scripts, videos) quickly to users worldwide.</li>
                <li><strong>Solution</strong>: CDNs cache copies of content in multiple geographic locations.</li>
                <li><strong>Benefit</strong>: Decreases latency by serving content from the nearest server to the user.</li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Types of Caching</h2>

            <h3>1. Browser Caching</h3>
            <ul>
                <li><strong>Description</strong>: Browsers store static resources (like images, CSS files, and JavaScript files) and DNS lookups locally.</li>
                <li><strong>Benefit</strong>: Speeds up page load times on subsequent visits by avoiding unnecessary network requests.</li>
            </ul>

            <h3>2. Content Delivery Network (CDN) Caching</h3>
            <ul>
                <li><strong>Description</strong>: CDNs cache content on servers around the world.</li>
                <li><strong>Benefit</strong>: Reduces latency and server load by delivering content from the closest geographic location to the user.</li>
            </ul>

            <h3>3. Application Server Caching</h3>
            <ul>
                <li><strong>Description</strong>: Servers cache frequently accessed data in memory.</li>
                <li><strong>Benefit</strong>: Minimizes database queries, reduces latency, and speeds up response times for dynamic content.</li>
            </ul>

            <h3>4. Global Caching</h3>
            <ul>
                <li><strong>Description</strong>: Data is cached across multiple regions and data centers.</li>
                <li><strong>Benefit</strong>: Ensures quick data access for a global user base and provides redundancy.</li>
            </ul>

            <h3>5. Mobile Caching</h3>
            <ul>
                <li><strong>Description</strong>: Dedicated caching for mobile users, often on separate servers optimized for mobile traffic.</li>
                <li><strong>Benefit</strong>: Enhances performance and reliability for mobile applications, which may have different requirements than desktop applications.</li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Challenges with Caching</h2>

            <h3>1. Data Consistency</h3>
            <ul>
                <li><strong>Issue</strong>: When the original data changes, cached copies may become outdated.</li>
                <li><strong>Solution</strong>:
                    <ul>
                        <li><strong>Cache Invalidation</strong>: Implement strategies to invalidate or update cached data when the source data changes.</li>
                        <li><strong>Time-to-Live (TTL)</strong>: Set expiration times for cached data to ensure regular updates.</li>
                        <li><strong>Event-Driven Updates</strong>: Push changes to cache when data is updated at the source.</li>
                    </ul>
                </li>
            </ul>

            <h3>2. Storage Overhead</h3>
            <ul>
                <li><strong>Issue</strong>: Caching requires additional storage resources, which can increase costs and complexity.</li>
                <li><strong>Solution</strong>:
                    <ul>
                        <li><strong>Selective Caching</strong>: Cache only the most frequently accessed data.</li>
                        <li><strong>Compression</strong>: Use data compression to reduce the storage footprint.</li>
                        <li><strong>Hierarchical Caching</strong>: Implement multi-level caching systems (e.g., L1, L2, L3 caches) to optimize storage and access speeds.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Conclusion</h2>
            <p>Caching is an essential strategy for optimizing performance in modern computing and web services. By storing frequently accessed data closer to the user or processor, caching significantly reduces latency and improves the user experience. While it introduces challenges like data consistency and storage management, effective caching strategies are vital for building scalable and high-performance applications.</p>
        </section>

        <hr>

        <section>
            <h2>In-Depth Look at Application Server Caching</h2>

            <h3>How Application Server Caching Works</h3>

            <h4>Data Storage</h4>
            <ul>
                <li><strong>In-Memory Storage</strong>: Frequently requested data is stored in the server's RAM for rapid access.</li>
                <li><strong>Types of Data Cached</strong>: Database query results, session data, user profiles, and other frequently accessed objects.</li>
            </ul>

            <h4>Data Retrieval</h4>
            <ul>
                <li><strong>Cache Hit</strong>: If the requested data is found in the cache, it's returned immediately to the user.</li>
                <li><strong>Cache Miss</strong>: If the data isn't in the cache, the server retrieves it from the database or persistent storage, stores it in the cache, and then serves it to the user.</li>
            </ul>

            <h4>Cache Management</h4>
            <ul>
                <li><strong>Eviction Policies</strong>:
                    <ul>
                        <li><strong>Least Recently Used (LRU)</strong>: Removes the least recently accessed items when the cache is full.</li>
                        <li><strong>Time-to-Live (TTL)</strong>: Sets an expiration time for cached items, after which they are invalidated.</li>
                    </ul>
                </li>
                <li><strong>Cache Invalidation</strong>: Ensures that stale data is removed or updated when the underlying data changes.</li>
            </ul>

            <h3>Types of Application Server Caching</h3>

            <h4>1. In-Memory Caching</h4>
            <ul>
                <li><strong>Description</strong>: Data is stored in the server's RAM.</li>
                <li><strong>Use Cases</strong>: Session data, user authentication tokens, frequently accessed configurations.</li>
            </ul>

            <h4>2. Distributed Caching</h4>
            <ul>
                <li><strong>Description</strong>: Cache is spread across multiple servers or nodes.</li>
                <li><strong>Use Cases</strong>: Large-scale applications requiring high availability and scalability.</li>
            </ul>

            <h4>3. Object Caching</h4>
            <ul>
                <li><strong>Description</strong>: Specific objects or data structures are cached to avoid repetitive computations or database access.</li>
                <li><strong>Use Cases</strong>: Complex computations, serialized objects, API responses.</li>
            </ul>

            <h4>4. Database Caching</h4>
            <ul>
                <li><strong>Description</strong>: Results from database queries are cached.</li>
                <li><strong>Use Cases</strong>: Read-heavy applications where certain queries are executed frequently.</li>
            </ul>

            <h3>Benefits of Application Server Caching</h3>
            <ul>
                <li><strong>Improved Performance</strong>: Faster data retrieval from memory compared to disk or network storage.</li>
                <li><strong>Reduced Latency</strong>: Minimizes response times, enhancing the user experience.</li>
                <li><strong>Lower Database Load</strong>: Decreases the number of direct database queries, reducing server strain.</li>
                <li><strong>Scalability</strong>: Enables the application to handle more concurrent users by offloading work from backend services.</li>
            </ul>

            <h3>Examples of Application Server Caching</h3>
            <ul>
                <li><strong>Web Applications</strong>: Caching user sessions, preferences, and dashboard data.</li>
                <li><strong>APIs</strong>: Storing responses for common requests to improve throughput.</li>
                <li><strong>E-commerce Platforms</strong>: Caching product details, pricing information, and inventory status.</li>
                <li><strong>Gaming Servers</strong>: Storing player statistics and game state data for quick access.</li>
            </ul>

            <h3>Challenges and Best Practices</h3>

            <h4>Data Consistency</h4>
            <ul>
                <li><strong>Challenge</strong>: Ensuring the cache reflects the most recent data.</li>
                <li><strong>Best Practices</strong>:
                    <ul>
                        <li><strong>Cache Invalidation Strategies</strong>: Use TTL, write-through, write-back, or event-based invalidation.</li>
                        <li><strong>Version Control</strong>: Implement versioning to track changes and update caches accordingly.</li>
                    </ul>
                </li>
            </ul>

            <h4>Memory Management</h4>
            <ul>
                <li><strong>Challenge</strong>: Preventing resource exhaustion due to limited memory.</li>
                <li><strong>Best Practices</strong>:
                    <ul>
                        <li><strong>Eviction Policies</strong>: Apply LRU, FIFO (First In, First Out), or LFU (Least Frequently Used) policies.</li>
                        <li><strong>Capacity Planning</strong>: Monitor cache usage and scale resources as needed.</li>
                    </ul>
                </li>
            </ul>

            <h4>Security</h4>
            <ul>
                <li><strong>Challenge</strong>: Protecting sensitive data stored in the cache.</li>
                <li><strong>Best Practices</strong>:
                    <ul>
                        <li><strong>Encryption</strong>: Encrypt sensitive data within the cache.</li>
                        <li><strong>Access Control</strong>: Restrict access to the cache using authentication and authorization mechanisms.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Addressing Data Consistency</h2>

            <h3>Version Control Systems</h3>
            <ul>
                <li><strong>Implementation</strong>: Use version numbers or timestamps for cached data.</li>
                <li><strong>Benefit</strong>: Allows the system to verify if the cached data is up-to-date before serving it.</li>
            </ul>

            <h3>Cache Invalidation Strategies</h3>
            <ul>
                <li><strong>Time-to-Live (TTL)</strong>: Cached data expires after a predefined period.</li>
                <li><strong>Event-Based Invalidation</strong>: The cache is updated or invalidated when specific events occur, such as data modifications.</li>
                <li><strong>Write-Through Caching</strong>: Updates occur simultaneously in both the cache and the database.</li>
            </ul>

            <h3>Push Updates</h3>
            <ul>
                <li><strong>Description</strong>: The system pushes changes to all cached copies when the original data is updated.</li>
                <li><strong>Benefit</strong>: Ensures all users receive the most recent data without waiting for the cache to expire.</li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Managing Storage Overhead</h2>

            <h3>Selective Caching</h3>
            <ul>
                <li><strong>Strategy</strong>: Cache only high-demand data.</li>
                <li><strong>Benefit</strong>: Reduces memory consumption by focusing on data that provides the most performance benefit.</li>
            </ul>

            <h3>Compression Techniques</h3>
            <ul>
                <li><strong>Strategy</strong>: Compress cached data using algorithms like GZIP.</li>
                <li><strong>Benefit</strong>: Saves storage space while maintaining acceptable access speeds.</li>
            </ul>

            <h3>Hierarchical Caching</h3>
            <ul>
                <li><strong>Implementation</strong>: Use multiple cache levels (e.g., L1, L2, L3) with varying speeds and sizes.</li>
                <li><strong>Benefit</strong>: Optimizes performance by storing the most frequently accessed data in the fastest cache.</li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Facebook's Caching System: A Case Study</h2>

            <h3>Multi-Level Caching Strategy</h3>

            <h4>L1 Cache (Client-Side)</h4>
            <ul>
                <li><strong>Managed By</strong>: TAO (The Associations and Objects) clients.</li>
                <li><strong>Function</strong>: Provides quick access to social graph data, such as user profiles and relationships.</li>
            </ul>

            <h4>L2 Cache (Server-Side)</h4>
            <ul>
                <li><strong>Managed By</strong>: Memcached, a distributed caching system.</li>
                <li><strong>Function</strong>: Stores frequently accessed data that didn't hit the L1 cache.</li>
            </ul>

            <h3>CacheLib: Facebook's Open-Source Caching Engine</h3>
            <ul>
                <li><strong>Description</strong>: A pluggable caching engine designed for web-scale services.</li>
                <li><strong>Features</strong>:
                    <ul>
                        <li><strong>Thread-Safe API</strong>: Ensures high throughput with minimal overhead.</li>
                        <li><strong>Customization</strong>: Allows for tailored caching solutions per service requirements.</li>
                    </ul>
                </li>
                <li><strong>Benefits</strong>: Enhances performance and scalability across Facebook's services.</li>
            </ul>

            <h3>Photo Caching</h3>
            <ul>
                <li><strong>Challenge</strong>: Efficiently serving billions of photos to users worldwide.</li>
                <li><strong>Solution</strong>:
                    <ul>
                        <li><strong>Haystack Machines</strong>: Specialized servers optimized for storing and retrieving photos.</li>
                        <li><strong>Multi-Layered Caching</strong>: Implements several cache layers to reduce latency and server load.</li>
                    </ul>
                </li>
                <li><strong>Benefit</strong>: Quick photo delivery with minimal delay.</li>
            </ul>

            <h3>Data Consistency and Invalidation</h3>
            <ul>
                <li><strong>Version Control</strong>: Tracks changes to ensure the latest data is served.</li>
                <li><strong>Cache Invalidation</strong>: Employs strategies to invalidate outdated data promptly.</li>
                <li><strong>Push Updates</strong>: Utilizes mechanisms to synchronize cache updates across all servers.</li>
            </ul>

            <h3>Storage Optimization</h3>
            <ul>
                <li><strong>Selective Caching</strong>: Focuses on caching data that significantly impacts performance.</li>
                <li><strong>Compression</strong>: Uses advanced algorithms to reduce the size of cached data.</li>
                <li><strong>Hierarchical Caching</strong>: Implements multiple cache tiers to balance speed and storage efficiency.</li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>TAO Clients at Facebook</h2>
            <p>TAO (The Associations and Objects) is Facebook's custom-built, distributed data store designed to manage the social graph efficiently.</p>

            <h3>Key Features of TAO Clients</h3>

            <h4>Two-Tiered Caching</h4>
            <ul>
                <li><strong>In-Memory Cache</strong>: Stores recently accessed data for quick retrieval.</li>
                <li><strong>Distributed Cache</strong>: Shares cached data across multiple servers for scalability.</li>
            </ul>

            <h4>Low-Latency Access</h4>
            <ul>
                <li><strong>Design Goal</strong>: Minimize response times for data retrieval and storage operations.</li>
                <li><strong>Impact</strong>: Maintains a responsive user experience, even under heavy load.</li>
            </ul>

            <h4>Scalability</h4>
            <ul>
                <li><strong>Capability</strong>: Handles billions of users and complex social interactions.</li>
                <li><strong>Approach</strong>: Distributes data and caching across numerous servers and data centers.</li>
            </ul>

            <h4>Data Consistency</h4>
            <ul>
                <li><strong>Strategies</strong>:
                    <ul>
                        <li><strong>Cache Invalidation</strong>: Updates or removes stale data promptly.</li>
                        <li><strong>Version Control</strong>: Ensures users receive the most recent information.</li>
                    </ul>
                </li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Conclusion</h2>
            <p>Caching is an indispensable component in the architecture of modern web services and applications. By strategically storing data closer to the point of use, caching systems like those employed by Facebook significantly improve performance and scalability. Understanding the types of caching, their benefits, and the challenges involved is crucial for designing efficient and responsive systems.</p>
        </section>

        <hr>

        <section>
            <h2>References</h2>
            <ul>
                <li>"The TAO of Facebook: Engineering an Efficient, Scalable Social Graph Data Store" - Facebook Engineering</li>
                <li>"CacheLib: A Caching Engine for Modern Web Services" - Facebook Open Source</li>
                <li>"Scaling Memcache at Facebook" - Facebook Engineering</li>
                <li>"Facebook's Photo Storage" - High Scalability Blog</li>
            </ul>
        </section>

        <hr>

        <footer>
            <p>&copy; 2024 Introduction to Caching Lecture Notes</p>
        </footer>
    </main>

    <script>
        // Check if the browser supports the Web Speech API
        if ('speechSynthesis' in window) {
            const readButton = document.getElementById('readButton');
            const pauseButton = document.getElementById('pauseButton');
            const stopButton = document.getElementById('stopButton');
            let utterance;
            
            // Function to log the available voices
            function listVoices() {
                const voices = speechSynthesis.getVoices();
                console.log('Available Voices:', voices);
    
                // Optionally, display the voices on the page for easier viewing
                const voiceList = document.createElement('ul');
                voices.forEach((voice, index) => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `Voice ${index}: ${voice.name} (${voice.lang}) - ${voice.default ? "Default" : "Not Default"}`;
                    voiceList.appendChild(listItem);
                });
                document.body.appendChild(voiceList); // Append voice list to the body for display
            }
    
            // Fetch and list voices
            speechSynthesis.onvoiceschanged = listVoices; // Fetch voices when they become available
    
            readButton.addEventListener('click', () => {
                if (speechSynthesis.speaking) {
                    return;
                }
    
                // Get the text content from the main section
                const text = document.querySelector('main').innerText;
    
                // Create a new utterance
                utterance = new SpeechSynthesisUtterance(text);
    
                // Optionally, set voice and other properties
                const voices = speechSynthesis.getVoices();
                const randomVoiceIndex = Math.floor(Math.random() * 5) + 1; // You can change this index to use different voices
                utterance.rate = 1.7; // For example, this will be 1.5 times faster than normal
                speechSynthesis.speak(utterance);
            });
    
            pauseButton.addEventListener('click', () => {
                if (speechSynthesis.speaking && !speechSynthesis.paused) {
                    speechSynthesis.pause();
                }
            });
    
            stopButton.addEventListener('click', () => {
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }
            });
    
        } else {
            // Fallback if Web Speech API is not supported
            document.getElementById('controls').innerHTML = '<p>Your browser does not support the Web Speech API.</p>';
        }
    </script>
    
</body>
</html>
